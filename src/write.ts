import semver from 'semver';
import { yellow, bold, red } from 'kolorist';
import { ResolvedChangelogOptions } from './types';
import { INITIAL_VERSION_MARK, NEXT_VERSION_MARK } from './constants';
import { stat, readFile, writeFile } from 'node:fs/promises';
import { getCommitTime, getCurrentGitBranch, getFirstGitCommit, getGitTags } from './git';
import { generate } from './generate';

export function formatTime(val: number): string {
    return val < 10 ? '0' + val : val.toString();
}

export async function genChangelog(config: ResolvedChangelogOptions, md: string) {
    const currentVer = semver.valid(config.from) || INITIAL_VERSION_MARK;
    const releaseVer = semver.valid(config.to) || NEXT_VERSION_MARK;
    let heading = '##';
    if (releaseVer !== NEXT_VERSION_MARK && !['patch', 'prepatch', 'prerelease'].includes(semver.diff(currentVer === INITIAL_VERSION_MARK ? 'v0.0.0' : currentVer, releaseVer)!)) {
        heading = '#';
    }

    const compareLink = `[${releaseVer}](https://github.com/${config.github}/compare/${config.from}...${config.to})`;

    const time = new Date(parseInt(await getCommitTime(config.to), 10) * 1000);
    const year = time.getFullYear();
    const month = time.getMonth() + 1;
    const date = time.getDate();

    const releaseDate = `(${year}-${formatTime(month)}-${formatTime(date)})`;

    const contentClip = md.split('\n');
    contentClip.length = contentClip.length - 2;
    contentClip.push('');

    const result = [`${heading} ${compareLink} ${releaseDate}`, '', contentClip.join('\n')];
    return { currentVer, releaseVer, result };
}

export async function writeChangelog(options: ResolvedChangelogOptions, content: string) {
    let needCreateFile = false;
    const fileStats = await stat(options.outfile).catch((err) => {
        if (err.code !== 'ENOENT') {
            console.log(red(err.toString()));
            process.exitCode = 1;
            return;
        }

        needCreateFile = true;
    });

    if (fileStats && !fileStats.isFile()) {
      console.log(yellow(`${bold(options.outfile)} is not a file. Skipping.`));
      process.exitCode = 1;
      return;
    }

    const lines: string[] = [];

    // Generate full changelog
    if (needCreateFile) {
        const tags = await getGitTags();
        const currentBranch = await getCurrentGitBranch();
        
        if (tags[tags.length - 1] !== currentBranch) {
            tags.push(currentBranch);
        }

        for (let i = tags.length - 1;i >= 0;i -= 1) {
            let from = tags[i - 1];
            const to = tags[i];

            if (i === tags.length - 1) {
                lines.push('# Changelog', '');
            }

            if (i === 0) {
                from = await getFirstGitCommit();
            }

            const { config, md } = await generate({
                ...options,
                from,
                to,
            });
            
            lines.push(...(await genChangelog(config, md.replaceAll('&nbsp;', ''))).result);
        }
    } else {
        const { currentVer, result } = await genChangelog(options, content.replaceAll('&nbsp;', ''));

        if (currentVer === INITIAL_VERSION_MARK) {
            console.log(yellow(`The changelog file ${bold(options.outfile)} is incomplete (It may not be entirely generated by Changelogithub), it is recommended to delete the changelog file and regenerate a full changelog by using Changelogithub.`));
            process.exitCode = 1;
            return;
        }

        lines.push(...result);

        const resolvedChangelog = await readFile(options.outfile, 'utf-8');
        const changelogClip = resolvedChangelog.split(currentVer);
        const changelogHeadClip = changelogClip[0].split('\n');
        changelogHeadClip[changelogHeadClip.length - 1] = lines.join('\n');
        changelogClip[0] = changelogHeadClip.join('\n');
        
        return writeFile(options.outfile, changelogClip.join(currentVer));
    }

    return writeFile(options.outfile, lines.join('\n'));
}
