import { readFile, stat, writeFile } from 'node:fs/promises'
import { bold, red, white, yellow } from 'kolorist'
import semver from 'semver'
import { INITIAL_VERSION_MARK, NEXT_VERSION_MARK } from './constants'
import { generate } from './generate'
import { filterTagsCreatedByRepo, getCurrentGitBranch, getFirstGitCommit, getGitCommitTime, getGitTags, getReferenceRepo, getUpstreamRepo } from './git'
import type { ResolvedChangelogOptions, UpstreamRepoInfo } from './types'

export function formatTime(val: number): string {
  return val < 10 ? `0${val}` : val.toString()
}

export async function genChangelog(config: ResolvedChangelogOptions, md: string) {
  const currentVer = semver.valid(config.from) || INITIAL_VERSION_MARK
  const releaseVer = semver.valid(config.to) || NEXT_VERSION_MARK
  let heading = '##'
  if (releaseVer !== NEXT_VERSION_MARK && !['patch', 'prepatch', 'prerelease'].includes(semver.diff(currentVer === INITIAL_VERSION_MARK ? 'v0.0.0' : currentVer, releaseVer)!))
    heading = '#'

  const compareLink = `[${releaseVer}](https://github.com/${config.github}/compare/${config.from}...${config.to})`

  const time = new Date(parseInt(await getGitCommitTime(config.to), 10) * 1000)
  const year = time.getFullYear()
  const month = time.getMonth() + 1
  const date = time.getDate()

  const releaseDate = `(${year}-${formatTime(month)}-${formatTime(date)})`

  const contentClip = md.split('\n')
  // Remove "View changes on Github"
  contentClip.length = contentClip.length - 2
  contentClip.push('')

  const result = [`${heading} ${compareLink} ${releaseDate}`, '', contentClip.join('\n')]
  return { currentVer, releaseVer, result }
}

export async function incompatibleChangelogError(options: ResolvedChangelogOptions, upstreamInfo: UpstreamRepoInfo) {
  const { outPath, overwrite } = options

  if (overwrite) {
    console.warn(yellow(`The changelog file ${white(bold(outPath))} is incompatible (It may not be entirely generated by Changelogithub, or it may be caused by a bug in Changelogithub). Trying regenerating changelog...`))
    return writeFullChangelog(options, upstreamInfo)
  }
  else {
    console.error(red(`The changelog file ${white(bold(outPath))} is incompatible (It may not be entirely generated by Changelogithub, or it may be caused by a bug in Changelogithub), it is recommended to delete the changelog file and regenerate a full changelog by using Changelogithub.`))
    process.exit(1)
  }
}

export async function writeFullChangelog(options: ResolvedChangelogOptions, upstreamInfo: UpstreamRepoInfo) {
  const lines: string[] = []
  let tags = await getGitTags()
  const currentBranch = await getCurrentGitBranch()

  // NEXT_VERSION
  if (tags[tags.length - 1] !== currentBranch)
    tags.push(currentBranch)

  if (options.strict)
    tags = await filterTagsCreatedByRepo(tags, upstreamInfo)

  for (let i = tags.length - 1; i >= 0; i -= 1) {
    let from = tags[i - 1]
    const to = tags[i]
    const github = options.strict ? options.github : await getReferenceRepo(upstreamInfo, to, options.github)

    if (i === tags.length - 1)
      lines.push('# Changelog', '')

    if (i === 0) {
      if (options.strict)
        continue

      from = await getFirstGitCommit()
    }

    const { config, md } = await generate({
      ...options,
      from,
      to,
      github,
    })

    lines.push(...(await genChangelog(config, md.replaceAll('&nbsp;', ''))).result)
  }

  return writeFile(options.outPath, lines.join('\n'))
}

export async function patchChangelog(options: ResolvedChangelogOptions, upstreamInfo: UpstreamRepoInfo, content: string) {
  const lines: string[] = []

  if (!options.strict)
    options.github = await getReferenceRepo(upstreamInfo, options.to, options.github)

  const { currentVer, result } = await genChangelog(options, content)

  if (currentVer === INITIAL_VERSION_MARK)
    return incompatibleChangelogError(options, upstreamInfo)

  lines.push(...result)

  const resolvedChangelog = await readFile(options.outPath, 'utf-8')
  let nextVersionClip = resolvedChangelog.split(`[${NEXT_VERSION_MARK}]`)

  const changelogClip: string[] = resolvedChangelog.split(`[${currentVer}]`)

  if (!(changelogClip.length > 1))
    return incompatibleChangelogError(options, upstreamInfo)

  let changelogHeadClip = changelogClip[0].split('\n')

  let currentVerHeading = changelogHeadClip[changelogHeadClip.length - 1]

  nextVersionClip = changelogClip[0].split(`[${NEXT_VERSION_MARK}]`)

  // Drop the changelog of NEXT_VERSION if exists
  if (nextVersionClip.length > 1) {
    changelogHeadClip = nextVersionClip[0].split('\n')
    const nextVersionChangelogClip = nextVersionClip[1].split('\n')
    currentVerHeading = nextVersionChangelogClip[nextVersionChangelogClip.length - 1]
  }

  changelogHeadClip[changelogHeadClip.length - 1] = lines.join('\n')
  changelogHeadClip.push(currentVerHeading)
  changelogClip[0] = changelogHeadClip.join('\n')

  return writeFile(options.outPath, changelogClip.join(`[${currentVer}]`))
}

export async function writeChangelog(options: ResolvedChangelogOptions, content: string) {
  let needCreateFile = false
  const fileStats = await stat(options.outPath).catch((err) => {
    if (err.code !== 'ENOENT') {
      console.error(red(String(err)))
      process.exit(1)
    }

    needCreateFile = true
  })

  if (fileStats && !fileStats.isFile()) {
    console.error(red(`${white(bold(options.outPath))} is not a file.`))
    process.exit(1)
  }

  const upstreamInfo = await getUpstreamRepo()

  // Generate full changelog
  if (needCreateFile)
    return writeFullChangelog(options, upstreamInfo)

  // Patch changelog
  else
    return patchChangelog(options, upstreamInfo, content)
}
